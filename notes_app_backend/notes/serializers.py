from rest_framework import serializers
from .models import Note, Tag

# A serializer converts Django model instances <-> JSON.
# DRF uses this to know how to return Note objects in API responses,
# and how to accept JSON from the frontend to create/update Note objects.

# ---------------------------------------------------------
# Tag Serializer
# ---------------------------------------------------------
class TagSerializer(serializers.ModelSerializer):
    """Serializes tag objects (id + name)"""
    class Meta:
        model = Tag
        fields = ["id", "name"]

# ---------------------------------------------------------
# Note Serializer
# ---------------------------------------------------------
class NoteSerializer(serializers.ModelSerializer):
    # Add a read-only field that shows the username of the note’s owner.
    # "source" tells DRF to use owner.username instead of a direct DB field.
    owner_username = serializers.ReadOnlyField(source="owner.username")

    # list of tag ID's
    tags = serializers.PrimaryKeyRelatedField(
        many = True,
        queryset = Tag.objects.all(),   # Prevent global access
        required = False
    )

    class Meta:
        model = Note    # This serializer is based on the Note model
        fields = [
            "id",               # Unique identifier for the note
            "title",            # Note title
            "content",          # Note content/body
            "created_at",       # Timestamp when created
            "owner",            # User ID of the note’s owner (foreign key)
            "owner_username",   # Username of the note’s owner (derived field)
            "tags",             # Tag ID
        ]
        # Mark certain fields as read-only so they can’t be modified via API requests.
        # - id and created_at are auto-generated by Django
        # - owner is set automatically in views (perform_create)
        # - owner_username is derived (not editable)
        read_only_fields = ["id", "created_at", "owner", "owner_username"]

    # --- Restrict tag choices to the current user's tags ---
    def get_fields(self):
        fields = super().get_fields()
        user = self.context["request"].user
        fields["tags"].queryset = Tag.objects.filter(owner = user)
        return fields

    # --- VALIDATION ---
    def validate_tags(self, tag_list):
        """Ensure a user cannot assign tags that belong to a different user."""
        user = self.context["request"].user
        for tag in tag_list:
            if tag.owner != user:
                raise serializers.ValidationError(
                    f"You do not own the tag: '{tag.name}'"
                )
        return tag_list
    
    # --- CREATE ---
    def create(self, validated_data):
        tags = validated_data.pop("tags", [])

        note = Note.objects.create(**validated_data)

        note.tags.set(tags)
        return note
    
    # --- UPDATE ---
    def update(self, instance, validated_data):
        tags = validated_data.pop("tags", None)

        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()

        if tags is not None:
            instance.tags.set(tags)
        
        return instance